---
interface Props {
  placeholder?: string;
}

const { placeholder = "Search for restaurants..." } = Astro.props;
---

<div class="search-container mb-6">
  <div class="relative">
    <input 
      type="text" 
      id="restaurant-search" 
      placeholder={placeholder}
      class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-spa-green focus:border-spa-green pl-10"
    />
    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
      </svg>
    </div>
  </div>
</div>

<script>
  /**
   * ⚠️ CRITICAL SEARCH FUNCTIONALITY - DO NOT REMOVE OR MODIFY ⚠️
   * 
   * This script implements the search functionality for restaurant cards.
   * It includes special handling for Vietnamese characters, mobile compatibility,
   * and multiple initialization approaches to ensure reliable operation.
   * 
   * If you encounter issues with search, check:
   * 1. Restaurant cards have proper data-name and data-address attributes
   * 2. The restaurant-grid class exists on the container
   * 3. The search input has id="restaurant-search"
   */

  // Function to normalize Vietnamese characters (removes diacritics for flexible matching)
  function normalizeVietnamese(str: string): string {
    return str.normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "") // Remove diacritics (accent marks)
      .toLowerCase()
      .trim();
  }

  // Debounce function to limit how often the search runs (improves performance)
  function debounce(func: Function, wait: number) {
    let timeout: ReturnType<typeof setTimeout>;
    return function(...args: any[]) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // Initialize search functionality
  function initializeSearch() {
    console.log('Initializing search functionality');
    
    // Get the search input element
    const searchInput = document.getElementById('restaurant-search') as HTMLInputElement;
    
    if (!searchInput) {
      console.error('Search input element not found');
      return;
    }
    
    // Function to get all restaurant cards
    function getRestaurantCards() {
      const cards = document.querySelectorAll('.restaurant-card');
      if (cards.length === 0) {
        console.warn('No restaurant cards found in the DOM');
      }
      return cards;
    }
    
    // Search function with debouncing (250ms delay for performance)
    const performSearch = debounce(function(searchTerm: string) {
      console.log(`Performing search for: "${searchTerm}"`);
      const restaurantCards = getRestaurantCards();
      console.log(`Found ${restaurantCards.length} restaurant cards`);
      
      // Add debugging for mobile devices
      console.log('Restaurant cards data:');
      restaurantCards.forEach(card => {
        console.log({
          name: card.getAttribute('data-name'),
          address: card.getAttribute('data-address')
        });
      });
      
      const normalizedSearchTerm = normalizeVietnamese(searchTerm);
      
      // Loop through all restaurant cards
      let matchCount = 0;
      restaurantCards.forEach(card => {
        const restaurantName = card.getAttribute('data-name') || '';
        const restaurantAddress = card.getAttribute('data-address') || '';
        
        // Normalize the restaurant data
        const normalizedName = normalizeVietnamese(restaurantName);
        const normalizedAddress = normalizeVietnamese(restaurantAddress);
        
        // Check if the card matches the search term (both with and without normalization)
        // This ensures matches work with or without Vietnamese diacritics
        const isMatch = 
          restaurantName.toLowerCase().includes(searchTerm) || 
          restaurantAddress.toLowerCase().includes(searchTerm) ||
          normalizedName.includes(normalizedSearchTerm) || 
          normalizedAddress.includes(normalizedSearchTerm);
        
        // Show or hide the card based on the match
        if (isMatch) {
          (card as HTMLElement).style.display = '';
          matchCount++;
        } else {
          (card as HTMLElement).style.display = 'none';
        }
      });
      
      console.log(`Search results: ${matchCount} matches found`);
      
      // Show a message if no results are found
      const noResultsMessage = document.getElementById('no-results-message');
      
      if (matchCount === 0 && searchTerm !== '') {
        if (!noResultsMessage) {
          const message = document.createElement('div');
          message.id = 'no-results-message';
          message.className = 'text-center py-8 text-gray-500';
          message.textContent = 'No restaurants found matching your search.';
          
          const restaurantGrid = document.querySelector('.restaurant-grid');
          if (restaurantGrid) {
            restaurantGrid.appendChild(message);
          } else {
            console.error('Restaurant grid container not found');
            // Fallback - append to the search container's parent
            const searchContainer = searchInput.closest('.search-container');
            if (searchContainer && searchContainer.parentElement) {
              searchContainer.parentElement.appendChild(message);
            }
          }
        }
      } else if (noResultsMessage) {
        noResultsMessage.remove();
      }
    }, 250); // Debounce by 250ms
    
    // Add multiple event listeners for better mobile compatibility
    // This ensures the search works across different devices and browsers
    ['input', 'change', 'keyup', 'focus', 'touchstart'].forEach(eventType => {
      searchInput.addEventListener(eventType, function() {
        const searchTerm = searchInput.value.toLowerCase().trim();
        performSearch(searchTerm);
      });
    });
    
    // Initial search if there's a value (e.g., from browser autofill)
    if (searchInput.value) {
      performSearch(searchInput.value.toLowerCase().trim());
    }
    
    // Mark as initialized to prevent duplicate initialization
    searchInput.dataset.initialized = 'true';
    console.log('Search functionality initialized successfully');
  }

  // ⚠️ IMPORTANT: Multiple initialization approaches ensure the search works reliably
  // across different devices and loading scenarios. DO NOT REMOVE ANY OF THESE APPROACHES.
  
  // Approach 1: DOMContentLoaded event
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSearch);
    console.log('Added DOMContentLoaded listener');
  } else {
    // DOM already loaded, initialize immediately
    console.log('DOM already loaded, initializing immediately');
    initializeSearch();
  }
  
  // Approach 2: Backup initialization with a slight delay
  // This helps on mobile where timing can be unpredictable
  setTimeout(() => {
    const searchInput = document.getElementById('restaurant-search') as HTMLInputElement;
    if (searchInput && !searchInput.dataset.initialized) {
      console.log('Backup initialization triggered');
      initializeSearch();
    }
  }, 500);
  
  // Approach 3: Window load event as final fallback
  window.addEventListener('load', () => {
    const searchInput = document.getElementById('restaurant-search') as HTMLInputElement;
    if (searchInput && !searchInput.dataset.initialized) {
      console.log('Window load fallback initialization');
      initializeSearch();
    }
  });

  // Approach 4: Mutation observer as a last resort for dynamically loaded content
  // This helps when restaurant cards are loaded after the initial page load
  try {
    const observer = new MutationObserver((mutations) => {
      const searchInput = document.getElementById('restaurant-search') as HTMLInputElement;
      if (searchInput && !searchInput.dataset.initialized) {
        console.log('Mutation observer triggered initialization');
        initializeSearch();
      } else if (searchInput && searchInput.dataset.initialized === 'true') {
        // If we already initialized but new cards were added, trigger a search
        const searchTerm = searchInput.value.toLowerCase().trim();
        if (searchTerm) {
          console.log('Re-running search after DOM mutation');
          // Force a re-search by clearing and re-setting the value
          const currentValue = searchInput.value;
          searchInput.value = '';
          setTimeout(() => {
            searchInput.value = currentValue;
            // Dispatch an input event to trigger the search
            searchInput.dispatchEvent(new Event('input'));
          }, 10);
        }
      }
    });
    
    // Start observing the document with the configured parameters
    observer.observe(document.body, { childList: true, subtree: true });
    console.log('Mutation observer set up for dynamic content');
  } catch (e) {
    console.error('Error setting up mutation observer:', e);
  }
</script>
